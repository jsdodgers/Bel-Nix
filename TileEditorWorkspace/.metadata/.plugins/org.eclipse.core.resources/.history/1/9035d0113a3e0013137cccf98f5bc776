import java.util.ArrayList;
import java.util.Arrays;



public class Main {
	public static void main(String[] args) {
	//	IEEEXtreme x = new IEEEXtreme();
	//	x.screens();
		IEEEXtreme2013 x = new IEEEXtreme2013();
//		x.acadox();
//		x.problem_as();
//		x.problem_ar();
		x.binary_palind();
	}
	
	
	public static void screens() {
		
	}
	
	class PriorityQueue<K extends Comparable<K>, V> {

		BinaryHeap heap;

		public PriorityQueue() {
			heap = new BinaryHeap();
		}

		public PriorityQueue(K head1, V head2) {
			heap = new BinaryHeap(head1, head2);
		}

		public void add(K key, V value) {
			heap.add(key, value);
		}

		public String toString() {
			return heap.toString();
		}

		public BinaryHeap.Entry remove() {
			return heap.remove();
		}

		public boolean isEmpty() {
			return heap.isEmpty();
		}

		class BinaryHeap {
			ArrayList<Entry> tree;
			int length = 0;

			public BinaryHeap() {
				tree = new ArrayList<Entry>();
			}

			public BinaryHeap(K head1, V head2) {
				tree = new ArrayList<Entry>();
				tree.add(new Entry(head1, head2));
				length = 1;
			}

			public Entry getRoot() {
				return tree.get(0);
			}

			public boolean isEmpty() {
				return length == 0;
			}

			public int size() {
				return length;
			}

			public boolean isRoot(int x) {
				return x == 0;
			}

			public boolean hasLeft(int x) {
				return x * 2 + 2 <= length;
			}

			public boolean hasRight(int x) {
				return x * 2 + 3 <= length;
			}

			public Entry leftChild(int x) {
				return tree.get(x * 2 + 1);
			}

			public Entry rightChild(int x) {
				return tree.get(x * 2 + 2);
			}

			public Entry getParent(int x) {
				return tree.get((x - 1) / 2);
			}

			public void add(K key, V value) {
				length++;
				tree.add(new Entry(key, value));
				int x = length - 1;
				while (!isRoot(x)) {
					Entry parent = getParent(x);
					Entry xEntry = tree.get(x);
					if (parent.getKey().compareTo(xEntry.getKey()) > 0) {
						tree.set(x, parent);
						tree.set((x - 1) / 2, xEntry);
					}
					else {
						break;
					}
					x = (x - 1) / 2;
				}
			}

			public Entry remove() {
				Entry e = getRoot();
				tree.set(0, tree.get(length - 1));
				length--;
				tree.remove(length);
				int x = 0;
				while (hasLeft(x)) {
					Entry l = leftChild(x);
					if (hasRight(x)) {
						Entry r = rightChild(x);
						if (l.compareTo(r) < 0) {
							if (l.compareTo(tree.get(x)) < 0) {
								tree.set(x * 2 + 1, tree.get(x));
								tree.set(x, l);
							}
							else {
								break;
							}
							x = x * 2 + 1;
						}
						else {
							if (r.compareTo(tree.get(x)) < 0) {
								tree.set(x * 2 + 2, tree.get(x));
								tree.set(x, r);
							}
							else {
								break;
							}
							x = x * 2 + 2;
						}
					}
					else if (l.compareTo(tree.get(x)) < 0) {
						tree.set(x * 2 + 1, tree.get(x));
						tree.set(x, l);
						break;
					}
					else {
						break;
					}
				}
				return e;
			}

			public String toString() {
				return tree.toString();
			}

			class Entry implements Comparable<PriorityQueue<K, V>.BinaryHeap.Entry> {
				K key;
				V value;

				public Entry(K key1, V value1) {
					key = key1;
					value = value1;
				}

				public K getKey() {
					return key;
				}

				public V getValue() {
					return value;
				}

				public String toString() {
					return "Key: " + key + "  Value: " + value;
				}

				public int compareTo(Entry o) {
					return key.compareTo(o.key);
				}
			}
		}

	}
	
	class Map {

		private ArrayList<Vertex> vertices;
		private ArrayList<Edge> edges;

		private boolean[][] k;
		private Vertex[][] p;
		private int[][] d;
		private boolean[] searched;

		public String toString() {
			return "Vertices:   " + vertices + "\nEdges:   " + edges;
		}

		public Map() {
			vertices = new ArrayList<Vertex>();
			edges = new ArrayList<Edge>();
		}

		public void startSearchArrays() {
			int size = vertices.size();
			k = new boolean[size][size];
			p = new Vertex[size][size];
			d = new int[size][size];
			searched = new boolean[size];
		}


		public int searchMap(int start, int end) {
			
			searchMap(start);
			
			int totalMiles = d[start][end];
			Vertex v = vertices.get(end);
			int v2 = end;
			while (v2 != start) {
				Vertex v3 = p[start][v2];
				v3.removeEdges();
				int v4 = vertices.indexOf(v3);
				v = v3;
				v2 = v4;
			}
			searchMap(start);
			totalMiles+=d[start][end];
			return totalMiles;
			
		}

		public void searchMap(int vert) {
			for (int n = 0; n < vertices.size(); n++) {
				k[vert][n] = false;
				p[vert][n] = null;
				d[vert][n] = Integer.MAX_VALUE;
				d[vert][vert] = 0;
			}

			PriorityQueue<Integer, Integer> pq = new PriorityQueue<Integer, Integer>();
			pq.add(0, vert);
			while (!pq.isEmpty()) {
				int x = pq.remove().getValue();
				Vertex v = vertices.get(x);
				if (!k[vert][x]) {
					k[vert][x] = true;
					for (Edge e : v.getEdgeList()) {
						Vertex v2 = e.getEnd();
						if (d[vert][vertices.indexOf(v2)] > (d[vert][x] + e.getDistance())) {
							d[vert][vertices.indexOf(v2)] = (d[vert][x] + e.getDistance());
							p[vert][vertices.indexOf(v2)] = v;
							pq.add(d[vert][vertices.indexOf(v2)], vertices.indexOf(v2));
						}
					}
				}
			}

		}

		public void addVertex(String data) {
			vertices.add(new Vertex(data));
		}

		public void addEdge(Integer data, int start, int end) {
			Edge e = new Edge(data, start, end);
			edges.add(e);
			vertices.get(start).addEdge(e);
		}

		public ArrayList<Vertex> getVertices() {
			return vertices;
		}

		public ArrayList<Edge> getEdges() {
			return edges;
		}

		class Vertex {
			private String data;
			private ArrayList<Edge> list;

			
			public void removeEdges() {
				for (Edge e : list) {
					e.setDistance(Integer.MAX_VALUE);
				}
			}
			
			public String toString() {
				return data;
			}

			public Vertex(String dat) {
				data = dat;
				list = new ArrayList<Edge>();
			}

			public void addEdge(Edge e) {
				list.add(e);
			}

			public void removeEdge(Edge e) {
				list.remove(e);
			}

			public String getData() {
				return data;
			}

			public void setData(String dat) {
				data = dat;
			}

			public ArrayList<Edge> getEdgeList() {
				return list;
			}
		}

		class Edge {
			private Integer distance;
			private Vertex start;
			private Vertex end;

			public String toString() {
				return "Dist: " + distance;
			}

			public Edge(Integer dat, Vertex start1, Vertex end1) {
				distance = dat;
				start = start1;
				end = end1;
			}

			public Edge(Integer dat, int start1, int end1) {
				distance = dat;
				start = vertices.get(start1);
				end = vertices.get(end1);
			}

			public Integer getDistance() {
				return distance;
			}

			public void setDistance(Integer dat) {
				distance = dat;
			}


			public Vertex getStart() {
				return start;
			}

			public Vertex getEnd() {
				return end;
			}
		}
	}
	
	
	
	public static void honeycomb(int x1, int y1, int x2, int y2) {
		
		int x = Math.abs(x1-x2);
		int y = Math.abs(y1-y2);
		int x3 = x1-x2;
		if(x==0) {
			if (y<2) System.out.println(10);
			else if(y==2) System.out.println(15);
			else {
				System.out.println((y-2)*10+15);
			}
		}
		else if(y==0) {
			System.out.println((x-1)*10+10);
		}
		else {
			if ((x3==0 && y==1) || (x3==1 && y<=1) || (x3==-1 && y == 0)) {
				System.out.println(10);
			}
		}
		
		
	}
	
	
	public static void bunnies(int x) {
		int rabbits = 0;
		int rabbits2 = x;
		int bunnies1 = 0;
		int bunnies2 = 0;
		for (int n=0;n<365;n+=15) {
			if (n%30==0) {
				System.out.println("yes");
				bunnies1*=.75;
				bunnies2*=.75;
				rabbits*=.75;
				rabbits2*=.75;
			}
			rabbits2 +=rabbits;
			rabbits = (int)(bunnies2*.7);
			bunnies2 = bunnies1;
			if (n>0)
			bunnies1 = (int)(rabbits2*.9);

		
		}
		System.out.println(bunnies1 + "  " + bunnies2 + "  " + rabbits + "  " + rabbits2 + "   " +  (bunnies1+bunnies2+rabbits+rabbits2));
	
	}
}


